# 正则表达式

## 定义
 正则表达式是对字符串操作的一种逻辑公式,就是用事先定义好的一些特定字符、及这些特定字符的组合,组成一个“规则字符串”,这个“规则字符串”用来表达对字符串的一种过滤逻辑.


## 语法
正则表达式由一些普通字符和一些元字符组成.普通字符就是我们平时常见的字符串、数字之类的,当然也包括一些常见的符号,等等.而元字符则可以理解为正则表达式引擎的保留字符,就像很多计算机语言中的保留字符一样,他们在正则引擎中有特殊的意义.

1. 字面量字符( Literal Characters )

字符 | 描述 | 示例
:----|:----|:----
\f | 换页符 | (u000C)
\n | 换行符 | (u000A)
\0 | 空字符 | ""
\r | 回车 | (u000D)
\o | NUL字符 | (u0000)
\t | 制表符 | (u0009)
\v | 垂直制表符 | (u000B)
\xnn | 由十六进制数nn指定的拉丁字符 | x0A等价于n
\uxxxx | 由十六进行xxxx指定的Unicode字符 | u0009等价与t
\cX | 控制字符(X的值必须是A-Z或a-z) | cJ等价于\n \cM等价于\r

2. 字符类( Character Classes )

字符 | 描述 | 示例
:----|:----|:----
xyz123 | 匹配字母和数字字符自身 | /abc/ 匹配 'abcd123'中的abc
[...] | 匹配位于括号内的任意字符 | [abc]匹配'plain'中的a
[^..] | 匹配不在括号之中的任意字符 | [^abc]匹配'plain'中的p
. | 除换行符和其它Unicode终止符()之外的任意字符  | . 匹配'plain'中的p
\w | 等价于[a-zA-Z0-9_],匹配字母数字和下划线 |w匹配'sina'中的s
\W | 等价于[^a-zA-Z0-9_],匹配除字母数字下划线之外的字符 |w不能匹配'sina'
\s | 任何Unicode空白符 |[ fnrtv]
\S | 任何非空白字符 |[^ fnrtv]
\d | 等价于[0-9] |d匹配'sina123'中的1
\D | 等价于[^0-9] |D不能匹配'sina1'中的1
[\b] | 退格直接量(特例) | backspace



3. 重复( Repetition )

字符 | 描述 | 示例
:----|:----|:----
{n,m} | 匹配至少n次,但不超过m次,n和m必须是非负整数,且n<=m  | [abc]匹配’plain’中的a
{n,} | 匹配至少n次 | o{2,} 不匹配’Bob’中的’o',但匹配’food’中的 o
{n} | 恰好匹配n次 | o{2} 不匹配’Bob’中的’o',但匹配’food’中的o
? | 匹配0次或1次,等价于{0,1} | zo? 匹配 "z" and "zo", 但不匹配"zoo"
+ | 匹配1次或多次,等价于{1,} | zo+ 匹配 "zo" and "zoo", 但不匹配 "z"
* | 匹配0次或多次,等价于{0,} | zo* 匹配 "z" 和 "zoo"


4. 非贪婪的重复(non-greedy)
字符 | 描述 | 示例
:----|:----|:----
*? +? ?? {n}? {n,}? {n,m}? | 在重复字符后加上问号,匹配模式就是非贪婪的匹配.这种模式会尽可能少的对目标字符串进行匹配 | o+? 匹配"oooo"中的一个"o", o+ 则匹配所有的 "o" , /a+?b/.exec(‘aaab’)


5. 选择、分组和引用

字符 | 描述 | 示例
:----|:----|:----
&#124; | (选择)匹配该符号左边或右边的子表达式 | (zf)ood匹配zood或food
(pattern) | (分组)将几个项目组合成一个单元,这个单元可由*,+,?和等符号使用,而且还可记住和这个组合匹配的字符以供后面的引用使用 | (AB) [1-9] 匹配 "A5", 字母A被保存,可通过n或RegExp的$1-$9引用该值
(?:pattern) | 只组合,不记忆 | ai(?:rR) 等价于airaiR
\n | 和第n个分组第一次匹配的字符相匹配,组索引是从左到右的'('数,'(?:'不计入索引 |


6. 指定匹配位置

字符 | 描述 | 示例
:----|:----|:----
^ | 匹配字符串的开头,在多行检索中,匹配一行的开头 | ^food匹配以food开头
$ | 匹配字符串的结尾,在多行检索中,匹配一行的结尾 | food&配以food结尾
\b | 匹配一个单词的边界 | er\b 匹配’never’中的’er’,但不匹配’verb’中的’er’.
\B | 匹配非单词边界 | 上面相反
(?=pattern) | 正向肯定预查,在任何匹配pattern的字符串开始处匹配查找字符串.这是一个非获取匹配,也就是说,该匹配不需要获取供以后使用 |“Windows(?=9598NT2000)”能匹配“Windows2000”中的“Windows”,但不能匹配“Windows3.1”中的“Windows”.预查不消耗字符,也就是说,在一个匹配发生后,在最后一次匹配之后立即开始下一次匹配的搜索,而不是从包含预查的字符之后开始
(?!pattern) | 正向否定预查,在任何不匹配pattern的字符串开始处匹配查找字符串.这是一个非获取匹配,也就是说,该匹配不需要获取供以后使用 |“Windows(?!9598NT2000)”能匹配“Windows3.1”中的“Windows”,但不能匹配“Windows2000”中的“Windows”.预查不消耗字符,也就是说,在一个匹配发生后,在最后一次匹配之后立即开始下一次匹配的搜索,而不是从包含预查的字符之后开始

7. 标志

字符 | 描述 
:----|:---- 
i | 忽略大小写
g | 执行全局匹配,即找到所有的匹配,而不是在找到第一个匹配后停止
m | 多行模式,^匹配一行的开头和字符串的开头,$匹配一行的结尾或字符串的结尾


## 使用

### 构建方法：
1. 字面量表示法,例如：var reg = /d+/i; 就表示一个正则表达式的实例,这个写法需要注意的地方是：正则表达式的主体部分,也就是示例中的 d+ ,必须位于“ / / ”之间,而标志位则需要跟在结束“/” 的后面.

2. 实例化RegExp对象,例如： var reg = new RegExp(“d+”,“igm”); 第一个参数是表达式的主体,而第二个参数则是标志位,此参数可选.

### 调用方法

1. String方法

* replace() 用以执行检索与替换,第一个参数是一个正则表达式,第二个是要替换的字符串.如果第一个参数是一个字符串,则replace将直接搜索这个字符串进行替换（只会替换第一个匹配）.

* match() 唯一参数是一个正则表达式(或是通过RegExp构造函数将其转换为正则表达式),返回的是一个由匹配结果组成的数组.

* split() 该方法可以按照传递的参数对字符串进行分割,会返回一个数组,里面包含了分割后的元素.

* search() 参数是一个正则表达式(如果不是,首先会通过RegExp构造函数将他转换成正则表达式),返回第一个与之匹配的字符串的起始位置,如果找不到,返回-1.（search方法不支持全局检索,他会忽略正则表达式中的修饰符g）


2. RegExp实例方法

* test( ) 方法只会返回一个Boolean值,如果匹配成功,则返回true,否则,返回false.

* exec() 用正则表达式模式在字符串中查找,并返回该查找结果的第一个值（数组）,如果匹配失败,返回null. 设置全局属性,每次只返回一个匹配项,第一次调用返回第一个匹配,第二次调用返回第二个匹配,lastIndex属性会增加.不在全局下,在统一字符串上多次调用exec()将始终返回第一个匹配项,lastIndex始终保持不变

## 常用案例

```js

```